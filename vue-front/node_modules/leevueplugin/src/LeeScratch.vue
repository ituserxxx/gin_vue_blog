<template>
  <div class="lee-scratch" ref="scratch">
    <canvas :width="width" :height="height" ref="canvasprizes"></canvas>
    <canvas class="canvas" :width="width" :height="height" ref="canvas" @mousedown.stop="mousedown"
            @mousemove.stop="mousemove" @mouseup.stop="down=false" @mouseleave="down=false" @touchstart.stop="touchstart"
            @touchmove.stop="touchmove" @touchend.stop="down=false"></canvas>
  </div>
</template>
<script>
export default {
    name: 'LeeScratch',
    inheritAttrs: false,
    data() {
        return {
            down: false,
            ctxprizes: null,
            ctx: null,
            oldX: 0,
            oldY: 0,
            offsetX: 0,//画布对整个页面的左边界
            offsetY: 0//画布对整个页面的上边界
        }
    },
    mounted() {
        this.createPrizes()//奖品结果输出文字
        this.fillRect()//填充画布
        this.chuli()
        window.addEventListener('resize', () => {
            this.chuli()
        })
    },
    methods: {
        createPrizes() {
            let xh = Math.round(Math.random() * (this.prizes.length - 1))
            let result = this.prizes[xh];
            let canvasprizes = this.$refs.canvasprizes
            let ctxprizes = canvasprizes.getContext('2d')
            this.ctxprizes = ctxprizes
            ctxprizes.save()
            ctxprizes.font = this.textSize + "px Arial";
            ctxprizes.fillStyle = this.textColor
            ctxprizes.textBaseline = "middle";
            ctxprizes.textAlign = "center";
            let txt = result.text
            ctxprizes.fillText(txt, this.width / 2, this.height / 2);
            ctxprizes.restore()
        },
        fillRect() {
            let canvas = this.$refs.canvas
            let ctx = canvas.getContext('2d')
            this.ctx = ctx
            ctx.save()
            if (!this.stripe) {
                ctx.fillStyle = this.background;
            } else {
                let radial = ctx.createLinearGradient(0, 0, this.width, this.height); //创建渐变
                for (let i = 0; i < 1; i += 0.01) {
                    let toi = Number(i.toFixed(2))
                    radial.addColorStop(toi, this.background);
                    let yu = Number((toi % 0.02).toFixed(2))
                    if (yu === 0.01) {
                        radial.addColorStop(toi, '#fff');
                    }
                }

                ctx.fillStyle = radial;

            }
            ctx.fillRect(0, 0, this.width, this.height);
            ctx.restore()
        },
        chuli() {
            let scratch = this.$refs.scratch
            if (scratch) {
                let scrollTop = document.documentElement.scrollTop||document.body.scrollTop
                let scrollLeft = document.documentElement.scrollLeft||document.body.scrollLeft
                this.offsetX = scratch.getBoundingClientRect().left + scrollLeft
                this.offsetY = scratch.getBoundingClientRect().top + scrollTop
            }
        },
        mousedown(e) {
            this.oldX = e.pageX - this.offsetX
            this.oldY = e.pageY - this.offsetY
            this.ctx.moveTo(this.oldX, this.oldY);
            this.down = true
        },
        mousemove(e) {
            this.ctx.lineCap = "round";
            this.ctx.lineJoin = "round";
            this.ctx.strokeStyle = '#000'
            this.ctx.lineWidth = this.size;
            if (this.down) {
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.lineTo(e.pageX - this.offsetX, e.pageY - this.offsetY);
                this.ctx.stroke();
            }
        },
        touchstart(e) {
            this.oldX = e.targetTouches[0].pageX - this.offsetX
            this.oldY = e.targetTouches[0].pageY - this.offsetY
            this.ctx.moveTo(this.oldX, this.oldY);
            this.down = true
        },
        touchmove(e) {
            this.ctx.lineCap = "round";
            this.ctx.lineJoin = "round";
            this.ctx.strokeStyle = '#000'
            this.ctx.lineWidth = this.size;
            if (this.down) {
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.lineTo(e.targetTouches[0].pageX - this.offsetX, e.targetTouches[0].pageY - this.offsetY);
                this.ctx.stroke();
            }
        },
    },
    props: {
        stripe: {
            type: Boolean,
            default: false
        },
        width: {
            type: Number,
            default: 260
        },
        height: {
            type: Number,
            default: 112
        },
        size: {
            type: Number,
            default: 20
        },
        textSize: {
            type: Number,
            default: 30
        },
        background: {
            type: String,
            default: '#eee'
        },
        textColor: {
            type: String,
            default: '#f20'
        },
        prizes: {
            type: Array,
            default() {
                return []
            }
        }
    }
};
</script>
<style>
.lee-scratch {
  position: relative;
}

.lee-scratch .canvas {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 2;
}
</style>
